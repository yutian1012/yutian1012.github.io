---
title: 常用字符编码
tags: [other]
---

字符编码是计算机技术的基石。全世界所有语言的符号都放在一起，也可以称为一个字符集，字符集中的字符没有顺序之分，在给字符集合中的每个字符都分配一个整数编号之后，这个字符集就有了顺序，成为编码字符集。

### 1. ASCII码
1）全称American Standard Code for Information Interchange（美国信息交换标准代码）。

2）ASCII 码：总共有 128 个，用一个字节的低 7 位表示。

0-31 是控制字符如换行回车删除等；
32-126 是打印字符，可以通过键盘输入并且能够显示出来。

3）回车换行符的理解

关于回车换行(‘\r\n’)，在屏幕还不普及的时代，结果输出经常是依赖于所谓的电传打印机，打印头沿着打印杆从左向右移动并打印出一个个字符，当碰到一个回车符时（CR，0x0D，’\r’），打印机就指示打印头重新回到最左边的位置上，这即是传统意义上的回车了。（你可以把打印头想像成一辆小车，回车即是退回原处，现代意义上的回车则通常包含回车与换行两个动作）

回车符后常跟着一个换行符（LF，0x0A，’\n’），打印机收到换行符就会指示滚筒滚动，这样，打印头就对准了纸张上的新的一行。如果没有换行，新的打印输出就会重叠在上一行上，有时走纸不顺畅时也会造成这种后果。

目前，在Windows系统上，回车键会产生两个字符CRLF，一起表示换行。Unix/Linux之类的则单独用LF表示换行，而苹果的Mac则单独用CR来表示换行。

![](/images/other/encode/ascii.gif)

注：低7位，占1个字节

### 2. ISO-8859-1码
1）对ASCII的扩展

ISO 组织在 ASCII 码基础上又制定了一些列标准用来扩展 ASCII 编码，它们是 ISO-8859-1 -- ISO-8859-15。

ISO-8859-1编码是单字节编码，向下兼容ASCII，其编码范围是0x00-0xFF，0x00-0x7F之间完全和ASCII一致，0x80-0x9F之间是控制字符，0xA0-0xFF之间是文字符号。

2）ISO-8859-1编码

ISO-8859-1 涵盖了大多数西欧语言字符，所有应用的最广泛。ISO-8859-1 仍然是单字节编码，它总共能表示 256 个字符。

![](/images/other/encode/iso-8859-1.png)

注：单字节编码，占1个字节

### 3. GB2312码
1）GB2312码--指的是机内码（不是区位码，也不是国际码）

全称是《信息交换用汉字编码字符集 基本集》，它是双字节编码，总的编码范围是 A1-F7（单字节），其中从 A1-A9 是符号区，总共包含 682 个符号，从 B0-F7 是汉字区，包含 6763 个汉字。

![](/images/other/encode/GB2312.png)

问题：为什么编码范围为A1-F7

引入：[69 197]2个字节的数组，编码是整体理解，还是将69单理解为字母E？
因为单个字节小于127的值，正好是ascii的值。GB2312为了兼容ASCII，每个字节的第一位为1，这样就屏蔽了低的0-127表示的ASCII。
区位码无法用于汉字通信，因为它可能与通信使用的控制码（00H~1FH）（即0~31）发生冲突。ISO2022规定每个汉字的区号和位号必须分别加上32（即二进制数00100000），经过这样的处理而得的代码称为国标交换码，简称交换码。

```
 1000 0000
+0010 0000
---------
 1010 0000  -->A0
```

注：GB2312码（双字节编码，占2个字节）

2）编码方式，采用了所谓的二维区位编号（只查看低7位）

横的叫区，竖的叫位，总共94个区，区和位的编号都从1开始。

汉字区:具体为16-87区，共87-16+1=72个区，理论空间为72×94=6768

空白区：最下面的88-94区是有待进一步标准化的空白区。

![](/images/other/encode/GB2312-parts.png)

关于前面的01-15区，概览图左上角的局部放大图

![](/images/other/encode/GB2312-part0-16.png)

3）区位码（这里的区号和位号的值都屏蔽掉高位后了）

![](/images/other/encode/GB2312-chinese-enocde.png)

所谓区位码就是这一94×94的大表格中的行号与列号了，均从1开始编号。汉字"啊"，它就是GB2312方案中的天字第一号汉字，它处于16区01位上，所以它的区位码即是1601。

4）国标码（国标交换码）

将区位码的区和位分别加上32（=0x20）就得到了国标码。

实例：
"啊"的区位码是16-01，分别加32，得到16+32-01+32=48-33，即是国标码。当然，你通常应该写成16进制，48-33即是0x30-0x21，所以3021即是"啊"十六进制的国标码，使用两字节保存，30为高字节，21为低字节。

任意一个图形字符都采用两个字节表示，每个字节均采用七位编码表示，只用了7位，这即是说最高位就是0了。

![](/images/other/encode/GB2312-international.png)

5）汉字内码（机内码，最终存储在计算机中）
汉字机内码，又称"汉字ASCII码"，简称"内码"，指计算机内部存储，处理加工和传输汉字时所用的由0和1符号组成的代码。
输入码被接受后就由汉字操作系统的"输入码转换模块"转换为机内码，与所采用的键盘输入法无关。机内码是汉字最基本的编码，不管是什么汉字系统和汉字输入方法，输入的汉字外码到机器内部都要转换成机内码，才能被存储和进行各种处理。

汉字在计算机内部其内码是唯一的。因为汉字处理系统要保证中西文的兼容，当系统中同时存在ASCII码和汉字国标码时，将会产生二义性。
例如：有两个字节的内容为30H和21H，它既可表示汉字"啊"的国标码，又可表示西文"0"和"!"的ASCII码。为此，汉字机内码应对国标码加以适当处理和变换。

解决方案：GB码的机内码为二字节长的代码，它是在相应GB码的每个字节最高位上加"1"
汉字机内码＝汉字国标码＋8080H。
例如，上述“啊”字的国标码是3021H，其汉字机内码则是B0A1H。

注：为了避免ASCII码和国标码同时使用时产生二义性问题，大部分汉字系统都采用将国标码每个字节高位置1作为汉字机内码。这样既解决了汉字机内码与西文机内码之间的二义性，又使汉字机内码与国标码具有极简单的对应关系。

6）汉字机内码、国标码和区位码三者之间的关系
区位码（十进制）的两个字节分别转换为十六进制后加20H得到对应的国标码；机内码是汉字交换码（国标码）两个字节的最高位分别加1，即汉字交换码（国标码）的两个字节分别加80H得到对应的机内码；区位码（十进制）的两个字节分别转换为十六进制后加A0H得到对应的机内码（因此我们常说GB2312是从A1开始编码的，即范围从A1-A7）。

7）问题一：双字节为256*256个区位，为什么使用94*94个区位？

GB2312采用7为编码：
GB2312方案规定，任意一个图形字符都采用两个字节表示，每个字节均采用七位编码表示（127×127个单元格），为了兼容ASCII（最高位为1，屏蔽掉0-127）。那么一字节就能表示127个状态。

GB2312首位为A1：
区位码无法用于汉字通信，因为它可能与通信使用的控制码（00H~1FH）（即0~31）发生冲突。ISO2022规定每个汉字的区号和位号必须分别加上32（即二进制数00100000），经过这样的处理而得的代码称为国标交换码，简称交换码。
```
 1000 0000
+0010 0000
---------
 1010 0000  -->A0
```

数值94：
0xFF代表结束，而且程序员一般概念上都将0xFF定义为“空”，为了避免代码习惯上的问题，末尾自然选择在了0xFE。因此，最重要的东西来了 0xFE-0xA0 + 1 = 94。所以最终只有94个有效位了，这也是前面为何是一个94×94的表格。

8）问题二：区位码和国标码的区和位为什么相差32

区位码无法用于汉字通信，因为它可能与通信使用的控制码（00H~1FH）（即0~31）发生冲突。，为了不与这些控制码冲突，加上32就能跳过它们了。

9）理解GB2312与ASCII码的兼容

GB2312中包含了引文字符，不过是作为所谓的全角字符来看待，但全角英文显示效果其实是很差的。这里的兼容之的是遇到01000110，即字节首位不是1的字节，当成ASCII码来处理，而不是当成GB2312的第一个字节来处理。

全角下的英文字母显示：

![](/images/other/encode/GB2312-char.png)

10）实例查看："啊"的GB2312的机内码

![](images/other/encode/GB2312-transfer.png)

```
@Test
public void testAh() throws UnsupportedEncodingException {
    String ah = "啊";
    System.out.println(DatatypeConverter.printHexBinary(ah.getBytes("GB2312")).equals("B0A1"));
    }
```

### 4. GBK编码
1）全称叫《汉字内码扩展规范》
GBK是国家技术监督局为 windows95 所制定的新的汉字内码规范，它的出现是为了扩展 GB2312，加入更多的汉字。它的编码范围是 8140 -- FEFE（首字节在81-FE 之间，尾字节在40-FE）之间总共有 23940 个码位，它能表示 21003 个汉字。
它的编码是和 GB2312 兼容的，也就是说用 GB2312 编码的汉字可以用 GBK 来解码，并且不会有乱码。

注：GBK码（双字节编码，占2个字节）

2）GBK的首字节

![](/images/other/encode/GBK-first-byte.png)

上面部分是兼容ASCII单字节编码。下面阴影部分是双字节编码中的第一个字节。

3）兼容ASCII码
当遇到的字节小于81，则取出一个字节作为ASCII码来处理。当遇到的字节大于等于81，则连续取出两个字节，使用GBK进行处理。

4）GBK的低字节

![](/images/other/encode/GBK-second-byte.png)

第二字节从0x40开始，不是从0x00也不是从0x80开始。

5）兼容GBK

"啊"位于A1处，所以它是兼容GB2312的，即将GB2312的编码位置原样不动的放置到GBK编码的位置处，达到兼容。

注："啊"下面的554A即是它的UTF-16编码（图中表是使用UTF-16显示的）。GBK与UTF-16之间编码的转换只能通过查表实现。通过查表可以找到UTF-16的554A码对应的GBK码为B0A1，即与GB2312的编码相同。

6）GBK所能表示的字符数量

GBK第一个字节可用126个标志
从81开始（0x80(=128)被用于欧元符），而0xFF则保留，实际共有128-2=126块。

GBK第二个字节可用190个标志
从0x40开始，另外0x7F和0xFF两处保留未定义。所以实际有12×16-2=192-2=190个字符。（即高4位表示的数量为16-4=12，乘以第4位16，减去2个未使用的标志）

粗略估算可得126×190=23940，所以GBK也就是两万多个字符这样子.

### 5. unicode
1）什么是Unicode

Unicode（统一码、万国码、单一码）是计算机科学领域里的一项业界标准,包括字符集、编码方案等。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求（标准）。

Unicode给每一个字符分配一个唯一的值，称为码点，但并不指定如何用这些值来表示原始文本。需要具体方案来具体指定。

UTF-8、UTF-16、UTF-32都是将数字转换到程序数据的编码方案（具体方案）。

2）Unicode问题

问题1（识别问题）：如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？

注：该问题导致出现了Unicode的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示Unicode（实现体系：UTF-8，UTF-16，UTF-32）。

问题2（占用空间问题）：

英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。

解决：使用UTF-8变长编码来节省空间。

### 6. UTF-16编码

1）什么是UTF-16编码

UTF-16 具体定义了 Unicode 字符在计算机中存取方法。UTF-16 用两个字节来表示 Unicode转化格式，这个是定长的表示方法，不论什么字符都可以用两个字节表示，两个字节是 16 个 bit，所以叫 UTF-16。UTF-16 表示字符非常方便，每两个字节表示一个字符，这个在字符串操作时就大大简化了操作，这也是 Java 以 UTF-16 作为内存的字符存储格式的一个很重要的原因。

注：UTF-16 统一采用两个字节表示一个字符，虽然在表示上非常简单方便，但是也有其缺点，有很大一部分字符用一个字节就可以表示的现在要两个字节表示，存储空间放大了一倍，在现在的网络带宽还非常有限的今天，这样会增大网络传输的流量，而且也没必要。

2）UTF-16如何处理ASCII码
UTF-16用两个字节表示一个字符，因此ASCII码字符对应的UTF-16的前9个bit位都为0。
如：
ASCII码字符A的码值为：0x41（十进制65）即0100 0001，
对应的UTF-16的码值为：0x0041，即0000 0000 0100 0001

注：UTF-16码（双字节编码，占2个字节，是定长编码）

### 7. UTF-8码

UTF-8就是在互联网上使用最广的一种Unicode的实现方式。其他实现方式还包括UTF-16（字符用两个字节或四个字节表示）和UTF-32（字符用四个字节表示），不过在互联网上基本不用。
UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号。

1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。

2）对于n字节的符号（n>1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。

3）原理对照表

```
Unicode符号范围        | UTF-8编码方式
(十六进制) 4个字节     | （二进制）
--------------------+---------------------------------------------
0000 0000 -- 0000 007F | 0xxxxxxx （2^7,128个标记）
0000 0080 -- 0000 07FF | 110xxxxx 10xxxxxx （2^11,2048个标记）
0000 0800 -- 0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx （2^16个标记）
0001 0000 -- 0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx （2^21个标记）
```

注：注：UTF-8编码，110xxxxx表示使用2个字节表示一个编码，开头使用了2个1。1110xxxx表示使用3个字节表示一个编码，开头使用了3个1。即如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。

4）实例

已知"严"的unicode是4E25（100111000100101，即0000 4E25）转换出其UTF-8编码值。

第一步（查表）："严"的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800--0000 FFFF），

第二步（确定格式）："严"的UTF-8编码需要三个字节，即格式是"1110xxxx 10xxxxxx 10xxxxxx"。

第三步（从低位向高位填值）：从"严"的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。

"严"的UTF-8编码是"11100100 10111000 10100101"，转换成十六进制就是E4 B8 A5。

参考：http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html

参考：https://my.oschina.net/goldenshaw/blog?catalog=536953