---
title: memcached应用
tags: [memecached]
---

参考：https://www.cnblogs.com/jiaosq/p/5812250.html

memcached解决的问题：

如果网站的高流量很大并且大多数的访问会造成数据库高负荷的状况下，使用 memcached 能够减轻数据库的压力。

注：memcached能够实现分布式（针对大数据量缓存中内存中），高性能（内存中访问速度更快）。

### 命令存储限制

1）key的限制(250byte)

memcached能接受的key的最大长度是250个字符。需要注意的是，250是memcached服务器端内部的限制。如果使用的Memcached客户端支持"key的前缀"或类似特性，那么key（前缀+原始key）的最大长度是可以超过250个字符的。推荐使用较短的key，这样可以节省内存和带宽。

2）value的限制(1M)

默认编译下Memcache只支持1M的Value。事实上由于存在序列化反序列化的过程，所以从实践的角度来说也不建 议把非常大的数据保存在Memcache中。Memcache适合面向输出的内容缓存，而不是面向处理的数据缓存，也就是不太适合把大块数据放进去拿出来处理之后再放回去，而是适合拿出来就直接给输出了或是拿出来不需要处理直接使用。

### 具体的应用策略

1）缓存的内容

a.缓存简单的查询结果

查询缓存存储了给定查询语句对应的整个结果集，最合适缓存那些经常被用到，但不会改变的SQL语句对查询到的结果集，比如载入特定的过滤内容。

```
//缓存查询语句，即将查询语句作为key，将结果集作为value存储到memcached中
$key = md5('SELECT * FROM rest_of_sql_statement_goes_here');
if ($memcache->get($key)) {
      return $memcache->get($key);
}else {
    result=.....;//查询数据，并缓存到memcache中
    $memcache->set($key, $result, TRUE, 86400);
    return $result;
}
```

注：如果查询语句发生变化，如查询条件变化了，对应的结果集也会改变，那么缓存的数据就不能取出来了。

注2：如果sql语句太长，可以使用md5摘要的形式计算出一个摘要值来作为key

b.缓存简单的基于行的查询结果

基于行的缓存会检查缓存数据key的列表，那些在缓存中的行可以直接被取出，不在缓存中的行将会从数据库中取出并以唯一的键为标识缓存起来，最后加入到最终的数据集中返回。随着时间的推移，大多数数据都会被缓存，这也意味着相比与数据库，查询语句会更多地从memcached中得到数据行。如果数据是相当静态的，我们可以设置一个较长的缓存时间。

注：基于行的缓存模式对下面这种搜索情况特别有用，数据集本身很大或是数据集是从多张表中得到。

c.缓存负责页面

缓存的不只是 SQL 数据，可以缓存最终完成的部分显示页面，以节省CPU计算时间，例如正在制作一张显示用户信息的页面，你可能得到一段关于用户的信息（姓名，生日，家庭住址，简介），然后你可能会将XML格式的简介信息转化为HTML格式或做其他的一些工作。相比单独存储这些属性，你可能更愿意存储经过渲染的数据块。那时你就可以简单地取出被预处理后的HTML直接填充在页面中，这样节省了宝贵的CPU时间。

注：这也需要根据观察服务器的运行情况来决定。如果cpu的使用率不高，也没必要这样做。

2）分层缓存

包括：应用本地缓存，数据库字段的sql缓存，memcached缓存等。

memcached可以高速处理大量的缓存数据，但是还是要根据系统的情况考虑维护多层的缓存结构。例如除了memcached缓存之外，还可以通过本地缓存（如ehcache、oscache等）建立起多级缓存。如，可以采用本地缓存缓存一些基本数据，少量但访问频繁的数据（如产品分类，连接信息，服务器状态变量，应用配置变量等），缓存这些数据并让他们尽可能的接近服务器是有意义的，这样可以帮助减少生成页面的时间，并且在memcached失效的情况下可以增加可靠性。

3）修改缓存数据时可以加锁

实例：要更新键A

a.添加一个锁，"lock:A"将A键锁住，这个键有一个持续几秒的过期时间（足够长以使你能完成计算和更新，也不要很长，因为如果锁进程挂了，这个键不会立即释放）。

b.如果锁添加操作成功了，你就拥有了锁。从缓存获取键A的数据；利用客户端程序更改数据；更新缓存键A的数据；删除键"lock:A"。

c.如果添加锁的操作失败，说明有人获取了锁。这时让应用做些合适的事，比如返回老数据，等待后重试，或是其他的。

注：类似的可以使用redis的watch命令

注2：如果该键不存在能，锁操作是否返回失败。保险的话应该先判断键是否存在。

### memcache中数据缓存的设计方案（key如何设计）

1）项目名称+实体名/表名+对象id--作为key

一般是项目名称+字符常量（实体名或表名等）+返回PO的id（或者唯一标示都可以）。

这种方式代码一般会嵌入到Service中（对象获取一般是从service调用dao的查询），从而破坏service的业务逻辑，耦合性较高。可以考虑在action层与service层中间加入一层，来降低耦合性。

2）类名+方法名+参数名--作为key

key可以通过类名+方法名+参数名等来组成

用spring-aop来拦截你要缓存的service，并实现缓存的操作。这种方法适用于分模块开发 ，因为调用的都是同一个类中的方法，但是拦截器也会在一定程度上影响性能。但是可以提高开发的效率，还有就是不会破坏service层的业务逻辑。

3）用sql语句+id（或者查询条件）

这种方式不是很好，查询条件的变化太多，导致不能很好的利用缓存。

### 如何批量清理缓存

参考：http://iyuanbo.iteye.com/blog/1177919

memcached不支持命名空间，也不支持使用任何类型的通配符或命名空间来完成删除操作。

1）思路：

memcache存取数据都是通过key来完成的。按照一定的方式拼装 key，即可模拟命名空间。

2）拼接方式

```
key = namespace_name + namespace_key + value_key ;
```

注1：namespace_name：命名空间的字符串

注2：namespace_key：命名空间的Key，称为namespace_version更好，每次想删除一组数据时提升版本。

注3：value_key：待缓存数据的Key，命名空间内数据的id

3）具体步骤：

```
//设定的命名空间名称为foo，得到现在的 namespace 的 版本号。
$ns_key = $memcache->get("foo_namespace_key"); 

//没有的话，随机生成一个版本号
if($ns_key===false){
    $memcache->set("foo_namespace_key", rand(1, 10000));
} 

//利用这个namespace_key
//foo为namespace，ns_key为取出的namespace_key，12345为value_key
$my_key = "foo_".$ns_key."_12345";

//根据生成的key取数据
$my_val = $memcache->get($my_key); 

//想要删除 命名空间 为 foo 的数据时，这样做：
//修改namespace_key的值。即提升namespace的版本。原来缓存的数据会因为超时，被重复利用。并没有违背主动删除数据。
$memcache->increment("foo_namespace_key");
```