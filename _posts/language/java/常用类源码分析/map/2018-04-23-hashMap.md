---
title: java中HashMap源码分析（一）
tags: [java]
---

参考：https://blog.csdn.net/ghsau/article/details/16843543

HashMap是最常用的集合类框架之一，它实现了Map接口，所以存储的元素也是键值对映射的结构，并允许使用null值和null键，其内元素是无序的，并且HashMap是线程不安全的。

注：如果要保证有序，可以使用LinkedHashMap。

1）hashcode方法

在hash相关的集合操作中，hashcode方法是一个关键。hashCode方法与equals方法都是Object类提供的，因此java中每个对象都拥有这两个方法，不同的对象对这两个方法进行了不同的实现。

约定：两个对象equals方法相等，那么在两个对象中的每个对象上调用hashCode方法都必须生成相同的整数结果。同理，两个对象不相等，那么在两个对象中的任一对象上调用hashCode方法必定会生成不同的整数结果。

注：hashCode方法，为哈希家族的集合类框架(HashMap、HashSet、HashTable)提供服务。

2）hashmap的结构

![](/images/java_basic/sorcecode/map/hashmap-constructor.png)

HashMap是数组和链表的结构。数组是hash表，即解决存储对象的问题。一般来讲最好的方式就是将put的数据通过key计算出数组的存储索引，然后将数据存放到该数组的位置处。

但是在存放数据时难免会遇到冲突碰撞问题，hashmap为解决冲突碰撞引入了链表，即将冲突的元素挂接到数组元素的链表中。

注：hash表为了存储数据，链表为了解决冲突配置。

3）如何保证key的唯一性

首先通过key的hash值定位放置的数组位置（bucketIndex），然后沿着链遍历比较key是否相同。在比较时会使用key的equals方法进行比较是否相同。找到则更新对应的value，找不到则在连的头部插入（最近访问的元素会在不久后再次被访问的概率较高原则）。

4）为什么HashMap容量一定要为2的幂？

HashMap中的数据结构是数组+单链表的组合，我们希望的是元素存放的更均匀，最理想的效果是，Entry数组中每个位置都只有一个元素，这样，查询的时候效率最高，不需要遍历单链表，也不需要通过equals去比较K，而且空间利用率最大，时间复杂度最优。

```
//位置下标的确定，n为集合的容量，为2的整数次幂
//下面的操作与取余操作时等价的
i = (n - 1) & hash
```

通过查看hashMap初始化，扩容resize方法，以及获取存放数据下标位置的代码我们能够看到，容量值均为2的整数次幂。2的整数次幂有一个好处就是可以利用位操作达到类似取余操作的目的。

注：hashMap在进行取余操作时使用的位操作实现的，而位操作的速度要远远大于取余操作

5）集合元素的删除

删除操作必须通过迭代器进行，否则会抛出异常。可通过查看remove方法进一步确定。

HashMap所有集合类视图所返回迭代器都是快速失败的，在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器自身的remove或add方法，其他任何时间任何方式的修改，迭代器都将抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败。注意，迭代器的快速失败行为不能得到保证，一般来说，存在不同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。至于为什么通过迭代器自身的remove或add方法就不会出现这个问题。