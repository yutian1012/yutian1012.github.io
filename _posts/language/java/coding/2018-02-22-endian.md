---
title: 字符集编码与大端小端
tags: [coding]
---

参考：http://blog.csdn.net/joenqc/article/details/71173382

1）定义

所谓大小端，是指字节存储或传输时的顺序。也就是看低字节在高内存地址还是低内存地址，低字节在前是小端，高字节在前就是大端。

![](/images/other/encode/endian.png)

注1：BigEndian(大端)，低字节在高内存地址。

注2：LittleEndian(小端)：低字节在低内存地址

2）BOM头

BOM表示大小端字节序与字符集编码之间的联系，即Byte Order Mark，字节顺序标记。

a.UTF-16编码的BOM头

例如可以以utf16编码将数据存储到文件中，在文件头部，会存入BOM，以表示在读取数据的时候是按照大端读取还是小端读取。

utf-16编码方式的代码单元为2字节，则一个代码单元内的两个字节的先后顺序对读取会产生影响，必须指定字节序，否则只能靠猜。

*注：FEFF表示大端，FFFE表示小端。*

b.UTF-8编码可不加BOM头

utf-8由于其特殊的变长编码规则，导致它是可以自解释的，所以以utf-8编码存储、传输数据时可以选择不加入BOM，同时这也是推荐的方式。

```
Unicode符号范围        | UTF-8编码方式
(十六进制) 4个字节     | （二进制）
--------------------+---------------------------------------------
0000 0000 -- 0000 007F | 0xxxxxxx （2^7,128个标记）
0000 0080 -- 0000 07FF | 110xxxxx 10xxxxxx （2^11,2048个标记）
0000 0800 -- 0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx （2^16个标记）
0001 0000 -- 0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx （2^21个标记）
```

utf-8代码单元为1字节，每个字节高位都有标识，每当读到一个字节时，可以根据其高位进行判断。如果读到0开头的字节，则此字节单独编码；如果读到110、1110、11110开头的字节，则接着读取对应个数的字节；如果读到10开头的字节，则继续读取，读到110、1110、11110开头的字节为止。

3）网络和操作系统中的Endian

在网络传输中，tcp协议采用大端字节序，也就是先接收到的字节为数据的高位。

在不同的操作系统平台中，内存采用的字节序可能不同，x86和一般的OS（如windows，FreeBSD,Linux）使用的是小端模式。但比如Mac-OS是大端模式。因此在不同平台之间进行网络传输时，需要进行特殊的转换。

4）使用java查看平台内存的字节存放顺序

在java中，通过ByteOrder.nativeOrder方法可以判断当前平台采用的时大端字节序还是小端字节序。

```
System.out.println(ByteOrder.nativeOrder());
```