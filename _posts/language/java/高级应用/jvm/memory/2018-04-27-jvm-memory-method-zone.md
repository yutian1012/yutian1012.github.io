---
title: jvm方法区
tags: [jvm]
---

所有线程共享，也将该区域称为持久代或永久代。jvm可以允许用户和程序指定方法区的初始大小，最小和最大尺寸。可通过-XX:PermSize和-XX:MaxPermSize设置永久代大小。

注：方法区同样存在垃圾收集，因为通过用户定义的类加载器可以动态扩展java程序，一些类也会成为垃圾。jvm可以回收一个未被引用类所占的空间，以使方法区的空间最小。

1）存放类型信息

类型信息是由类加载器在类加载时从类文件中提取出来的。因为方法区是被所有线程共享的，所以必须考虑数据的线程安全。假如两个线程都在试图找lava的类，在lava类还没有被加载的情况下，只应该有一个线程去加载，而另一个线程等待。

类型信息：

a.类的完整名称

这个类型的完整有效名，在java源代码中，完整有效名由类的所属包名称加一个”.”，再加上类名。但在类文件里，所有的”.”都被斜杠“/”代替。

b.类的父类信息

这个类型直接父类的完整有效名（除非这个类型是interface或是java.lang.Object，两种情况下都没有父类) 

c.类修饰符

这个类型的修饰符（public,abstract, final的某个子集）

d.直接接口列表

这个类型直接接口的一个有序列表

2）类型的常量池(constant pool) 

jvm为每个已加载的类型都维护一个常量池。常量池就是这个类型用到的常量的一个有序集合，包括实际的常量（string,integer,和floatingpoint常量）以及对类型，域和方法的符号引用。

常量池中的数据项象数组项一样，是通过索引访问的。 因为常量池存储了一个类型所使用到的所有类型，域和方法的符号引用，所以它在java程序的动态链接中起了核心的作用。

注：一个类有自己的常量池，这些常量池可在该类的多个对象中共享。

3）域(Field)信息 

jvm必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。

域的相关信息包括：

域名，域类型，域修饰符（public,private,protected,static,final volatile,transient的某个子集）。

4）方法(Method)信息 

jvm必须保存所有方法的以下信息，同样域信息一样包括声明顺序。

方法的相关信息包括：

方法名，方法的返回类型(或void)，方法参数的数量和类型(有序的)，方法的修饰符（public,private,protected,static,final,synchronized,native,abstract的一个子集）。

注：除了abstract和native方法外，其他方法还有保存方法的字节码(bytecodes)操作数栈和方法栈帧的局部变量区的大小。

5）除了常量外的所有静态(static)变量

静态变量也称为类变量，被类的所有实例共享，即使没有类实例时你也可以访问它。这些变量只与类相关，所以在方法区中，它们成为类数据在逻辑上的一部分。在jvm使用一个类之前，它必须在方法区中为每个non-final类变量分配空间。

6）对类加载器的引用 

jvm必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么jvm会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。

jvm在动态链接的时候需要这个信息。当解析一个类型到另一个类型的引用的时候，jvm需要保证这两个类型的类加载器是相同的。这对jvm区分名字空间的方式是至关重要的。