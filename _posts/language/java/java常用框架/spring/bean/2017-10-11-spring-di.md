---
title: spring循环依赖
tags: [spring]
---

参考：http://jinnianshilongnian.iteye.com/blog/1415278

Spring容器循环依赖包括构造器循环依赖和setter循环依赖，构造函数的循环依赖将抛出异常。而setter循环依赖只能解决bean的scope作用域为single的对象，不能解决bean的作用域为prototype的对象。

1）循环依赖

循环依赖就是循环引用，就是两个或多个Bean相互之间都相互持有对方，比如CircleA引用CircleB，CircleB引用CircleC，CircleC引用CircleA，则它们最终反映为一个环。

![](/images/java_structure/spring/bean/di-circle.JPG)

2）实例

CircleA类引用CircleB实例

```
@Component
public class CircleA {
    @Resource
    private CircleB circleB;  
    public CircleA() {  
    } 
    //@Autowired
    public CircleA(CircleB circleB) {  
        this.circleB = circleB;  
    }  
    public void setCircleB(CircleB circleB)   
    {  
            this.circleB = circleB;  
        }  
    public void a() {  
       circleB.b();  
    }
}
```

CircleB类引用CircleC实例

```
@Component
public class CircleB {
    @Resource
    private CircleC circleC;  
    public CircleB() {  
    } 
    //@Autowired
    public CircleB(CircleC circleC) {  
        this.circleC = circleC;  
    }  
    public void setCircleC(CircleC circleC)   
    {  
        this.circleC = circleC;  
    }  
    public void b() {  
        circleC.c();  
    }  
}
```

CircleC类引用CircleA实例

```
@Component
public class CircleC {
    @Resource
    private CircleA circleA;  
    public CircleC() {  
    }
    //@Autowired
    public CircleC(CircleA circleA) {  
        this.circleA = circleA;  
    }  
    public void setCircleA(CircleA circleA)   
    {  
        this.circleA = circleA;  
    }  
    public void c() {  
        circleA.a();  
    }  
}
```

3）使用构造函数方式设置依赖

applicationContext.xml

```
<?xml version="1.0" encoding="UTF-8"?>  
<beans xmlns="http://www.springframework.org/schema/beans"  
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context  
    http://www.springframework.org/schema/context/spring-context.xsd">
  
  <bean id="circleA" class="org.sjq.source.spring.circle.CircleA">  
    <constructor-arg index="0" ref="circleB"/>  
  </bean>  
  <bean id="circleB" class="org.sjq.source.spring.circle.CircleB">  
    <constructor-arg index="0" ref="circleC"/>  
  </bean>  
  <bean id="circleC" class="org.sjq.source.spring.circle.CircleC">  
    <constructor-arg index="0" ref="circleA"/>  
  </bean>     
</beans>
```

注：配置文件可以使用xml中定义bean的方式，也可以使用注解的方式实现

```
<context:component-scan base-package="org.sjq.source.spring.circle"></context:component-scan>
```

4）运行测试

```
@Test
public void testCircle() {
  new ClassPathXmlApplicationContext("applicationContext.xml");
}
```

抛出异常信息：

```
nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'circleA': Requested bean is currently in creation: Is there an unresolvable circular reference。
```

5）构造器循环依赖异常原理

构造器循环依赖：表示通过构造器注入构成的循环依赖，此依赖是无法解决的，只能抛出BeanCurrentlyInCreationException异常表示循环依赖。

如在创建CircleA类时，构造器需要CircleB类，那将去创建CircleB，在创建CircleB类时又发现需要CircleC类，则又去创建CircleC，最终在创建CircleC时发现又需要CircleA，再次创建A时，发现创建Bean池中已经存在CircleA了。从而形成一个环，没办法创建。

Spring容器将每一个正在创建的Bean 标识符放在一个"当前创建Bean池"中，Bean标识符在创建过程中将一直保持在这个池中，因此如果在创建Bean过程中发现自己已经在"当前创建Bean池"里时将抛出BeanCurrentlyInCreationException异常表示循环依赖；而对于创建完毕的Bean将从"当前创建Bean池"中清除掉。

6）set方式循环依赖

修改配置文件applicationContext.xml

```
<bean id="circleA" class="org.sjq.source.spring.circle.CircleA">  
    <property name="circleB" ref="circleB"/>  
</bean>  
<bean id="circleB" class="org.sjq.source.spring.circle.CircleB">  
    <property name="circleC" ref="circleC"/>
</bean>  
<bean id="circleC" class="org.sjq.source.spring.circle.CircleC">  
    <property name="circleA" ref="circleA"/>
</bean>
```

再次运行测试，能正确解决循环依赖。

7）原理分析

第一步：Spring容器创建单例"circleA"Bean，首先根据无参构造器创建Bean，并暴露一个"ObjectFactory"，返回一个提前创建中的Bean，并将"circleA"标识符放到"当前创建Bean池"；然后进行setter注入"circleB"。

第二步：Spring容器创建单例"circleB"Bean，首先根据无参构造器创建Bean，并暴露一个"ObjectFactory"，返回一个提前创建中的Bean，并将"circleB"标识符放到"当前创建Bean池"，然后进行setter注入"circleC"。
 
第三步：Spring容器创建单例"circleC"Bean，首先根据无参构造器创建Bean，并暴露一个"ObjectFactory"，返回一个提前创建中的Bean，并将"circleC"标识符放到"当前创建Bean池"，然后进行setter注入"circleA"；进行注入"circleA"时（即CircleC的setCircleA方法调用），由于提前暴露了"ObjectFactory"工厂，从而使用它返回提前创建中的Bean。

最后：在依赖注入"circleB"和"circleA"，完成setter注入。

8）为bean设置scope为prototype

修改配置文件applicationContext.xml

```
<bean id="circleA" class="org.sjq.source.spring.circle.CircleA" scope="prototype">  
    <property name="circleB" ref="circleB"/>  
</bean>  
<bean id="circleB" class="org.sjq.source.spring.circle.CircleB" scope="prototype">  
    <property name="circleC" ref="circleC"/>
</bean>  
<bean id="circleC" class="org.sjq.source.spring.circle.CircleC" scope="prototype">  
    <property name="circleA" ref="circleA"/>
</bean>
```

再次运行测试类，抛出的异常信息与构造函数注入依赖错误是相同的。因此，对于"prototype"作用域Bean，Spring容器无法完成依赖注入。因为"prototype"作用域的Bean，Spring容器不进行缓存，因此无法提前暴露一个创建中的Bean。