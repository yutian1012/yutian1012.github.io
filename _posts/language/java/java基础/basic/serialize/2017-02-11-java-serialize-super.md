---
title: java序列化与父类
tags: [basic]
---

*序列化操作与父类无关，只有反序列化才会涉及到父类*

### 序列化与父类

1）序列化父类

要想将父类对象也序列化，就需要让父类也实现Serializable接口。如果父类不实现的话的，就需要有默认的无参的构造函数。 

2）利用父对象隐藏不想序列化的字段

根据父类对象序列化的规则，我们可以将不需要被序列化的字段抽取出来放到父类中，子类实现Serializable接口，父类不实现Serializable接口，同时提供默认构造方法，根据父类序列化规则，父类的字段数据将不被序列化。

3）序列化类的所有子类本身都是可序列化的

如果一个父类实现了Serializable接口，那么其子类默认也实现了该接口，即该子类可以进行序列化操作。

### 反序列化与父类

1）反序列化的原理

a.父类没有实现Serializable接口

在父类没有实现Serializable接口时，虚拟机是不会序列化父对象，而一个Java对象的构造必须先有父对象，才有子对象，反序列化也不例外。所以反序列化时，为了构造父对象，只能调用父类的无参构造函数作为默认的父对象。

因此当取父对象的变量值时，它的值是调用父类无参构造函数后的值。如果你考虑到这种序列化的情况，在父类无参构造函数中对变量进行初始化，否则的话，父类变量值都是默认声明的值，如int型的默认是0，string型的默认是null。

注：可在父类的无参构造函数中初始化父类对象成员，该构造函数会在反序列化时被执行。

b.父类实现了Serializable接口

当父类实现了Serializable接口，那么父类中的成员变量也会被序列化。同时，如果父类不提供无参构造函数，也能正常实现子类对象的反序列化。即在反序列化时，会调用父类的带参构造函数。

2）反序列化对父类的要求

a.没有实现Serializable接口，则需提供无参构造函数

父类没有实现Serializable接口，而子类要想反序列化成功，父类必须提供默认无参构造函数。

b.实现了Serializable接口，可不提供无参构造函数

如果父类实现了Serializable接口，那么子类在反序列化时，会调用父类的带参构造函数。