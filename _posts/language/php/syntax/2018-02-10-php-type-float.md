---
title: php数据类型--浮点型
tags: [php]
---

浮点型（也叫浮点数 float，双精度数 double 或实数 real）

php遵循IEEE754规范，float占用4字节，double占用8字节

1）14位精度

浮点数的精度最大14位十进制数值（这里的精度不是指小数点后的位数，而是所有的数值，包括小数点前的数值），从左边开始计算第一个非0的值就是精度开始。

```
<?php
    # 输出：0.23456789022223
    echo 0.23456789022222988;
    # 输出：1.2345678902222
    echo 1.23456789022222988;
?>
```

注：精度值包括小数点前后数值，但不包括小数点

2）科学计数法表示

```
<?php
    # 输出：2.3456789022E-5
    # 即在2的前面添加5个0，即小数的向左移动5位
    echo 0.000023456789022;
?>
```

### IEEE 754(标准)

参考：https://www.2cto.com/kf/201706/649921.html

PHP遵循IEEE-754双精度，

a.浮点数，以64位的双精度，采用1位符号位(E)，11指数位(Q)，52位尾数(M)表示(一共64位)。

b.符号位：最高位表示数据的正负，0表示正数，1表示负数。

c.指数位：表示数据以2为底的幂，指数采用偏移码表示

d.尾数：表示数据小数点后的有效数字

### php浮点数精度损失问题

php在使用浮点数进行计算时，是不可靠的。

参考：http://www.jb51.net/article/65984.htm

1）实例1

```
<?php
    $f = 0.57;
    # 输出56而不是57
    echo intval($f * 100);
?>
```

0.57用二进制表示的数值为：

```
# 0.57的二进制表示基本上(52位)是，不能准确的表述，后面的二进制数值被省略掉了
00100011 11010111 00001010 00111101 01110000 10100011 1101
# 如果只有52位的话，0.57 --> 0.56999999999999995
```

2）实例2

```
<?php
    $a = 0.1;
    $b = 0.9;
    $c = 1;

    var_dump(($a+$b)==$c);//true
    var_dump(($c-$b)==$a);//false
    
    //输出精度设置为20位
    printf("%.20f", $a+$b); // 1.00000000000000000000
    printf("%.20f", $c-$b); // 0.09999999999999997780
?>
```

### 浮点数的正确计算

参考：http://blog.csdn.net/fdipzone/article/details/48106065

1）使用round方法处理后再比较

```
<?php
    $a = 0.1;
    $b = 0.9;
    $c = 1;
    
    # 使用round函数前返回的false，使用round函数后返回true，小数点精确1位
    var_dump(($c-$b)==$a);                   // false
    var_dump(round(($c-$b),1)==round($a,1)); // true
?>
```

2）使用高精度运算方法

首先进行运算时，使用高精度的运算方法，这样可以保证精度不丢失。

a.运算方法

```
bcadd 将两个高精度数字相加 
bccomp 比较两个高精度数字，返回-1,0,1 
bcdiv 将两个高精度数字相除 
bcmod 求高精度数字余数 
bcmul 将两个高精度数字相乘 
bcpow 求高精度数字乘方 
bcpowmod 求高精度数字乘方求模 
bcscale 配置默认小数点位数，相当于Linux bc中的”scale=” 
bcsqrt 求高精度数字平方根 
bcsub 将两个高精度数字相减
```

b.实例

```
<?php
    $a = 0.1;
    $b = 0.9;
    $c = 1;

    var_dump(($c-$b)==$a);          // false
    var_dump(bcsub($c, $b, 1)==$a); // true
?>
```