---
title: 计算机中实数的规格化表示
tags: [computer]
---

### 规格化表示

每个数字介于0和基数之间，包括0，小数点左侧的数字不为0。因此针对二进制数值，小数点前规格化后为1。从而唯一规定了小数点的位置。尾数的长度将影响数的精度。其符号将决定数的符号，浮点数的阶码相当于数学中的指数，其大小将决定数的表示范围。

注：通过修改阶码并同时移动尾数的方法使其满足这种规范。

规格化过程：

```
# 规格化
# 非规格化数据（补码数值）
0.1xxx...
# 规格化后，比原数值能多表示1位，精度更精确
1.xxx...
# 一般格式化后的值的第一位是可以省略的，因为默认值是1
```

1）左规（向左规格化）

尾数左移一位，阶码加1。

注：移动的是数值而不是小数点

2）右规（向右规格化）

尾数右移一位，阶码减1。

3）隐藏位

对于规格化浮点数小数点后第一个值是固定的（正数：1，负数：原码1，补码0），所以该位往往缺省，称为隐藏位。

注：隐藏位只能有1位，即使下一位与第一位相同，也不能省略。

注2：IEEE754规范单精度的基数位为23，实际能表示24位有效位。

4）规格化形式

规格化有补码或原码的规格化。

a.原码规格化后的形式

正数规格化小数点后的第一个值为1，而负数时也为1。即原码的正、负数小数点后的第一个值都为1。

```
# 正数规格化的形式
# 小数点前的数值为符号位，因此规格化后的尾数最高位为1
0.1xxx...xxx

# 负数规格化的形式
1.1xxx...xxx
```

b.补码规格化后的形式

在尾数用补码表示时，规格化浮点数应满足尾数最高数位与符号位不同，如相同就是不满足规格化。即正数补码规格化后小数点后的第一位为1，而负数时为0。

```
# 正数的补码规格化后的形式
0.1xxx...xxx

# 负数的补码规格化后的形式
1.0xxx...xxxx
```

### 规格化实例

1）实例：十进制-27/64表示成规格化浮点数

```
# -27/64转存二进制为（乘2取整）
0.011011 = 0.110110 * 2^(-1)
# 数值为负数，因此尾数的符号位为1

# 规格化要求尾数表示为0.1xxx的形式
# 阶符为负数，因此值为1，

# 阶码-001原码为101，补码为111，不用移码？
# 尾数用原码表示为：110110
# 输出结果：阶符 阶码 尾符 尾码
1 111 1 110110
```
