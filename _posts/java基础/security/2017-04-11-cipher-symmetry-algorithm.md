---
title: 对称加密--分组加密的四种工作模式
tags: [security]
---

以DES算法为例讨论

参考：http://blog.csdn.net/wyq_841943/article/details/50156957

参考：http://blog.csdn.net/includeiostream123/article/details/51066799

### 1. 对称加密算法参数

密钥长度；（关系到密钥的强度），

加密模式；（ecb、cbc等等），

块加密算法里的填充方式区分

2）加密模式

DES对于加密模式，有ECB、CBC等不同的区分

```
Cipher c = Cipher.getInstance("DES/CBC/PKCS5Padding"); 
```

注：说明DES使用的是CBC的加密模式，填充使用PKCS5Padding方式

### 2. ECB（Electronic Codebook，电子密码本模式）

将加密的数据分成若干组，每组的大小跟加密密钥长度相同。然后每组都用相同的密钥加密, 比如DES算法, 如果最后一个分组长度不够64位,要补齐64位；

1）加密算法过程

```
Enc(X,Y)是加密函数
Dec(X,Y)是解密函数
Key是加密密钥；

Pi ( i = 0,1…n)是明文块，大小为64bit；
Ci ( i = 0,1…n)是密文块，大小为64bit;

ECB加密算法可表示为：
Ci = Enc(Key, Pi)
ECB解密算法可以表示为：
Pi = Dec(Key,Ci)
```

2）算法特点：

（1）长度限制：每次Key、明文、密文的长度都必须是64位；

（2）数据块重复排序不需要检测；

（3）一致性：相同的明文块(使用相同的密钥)产生相同的密文块，容易遭受字典攻击；

（4）加密独立性：一个错误仅仅会对一个密文块产生影响；（与CBC比较）

![](/images/java_basic/security/des-ecb-enc.jpg)

![](/images/java_basic/security/des-ecb-dec.jpg)

### 3. CBC（Cipher Block Chaining，加密块链模式）

与ECB模式最大的不同是加入了初始向量。

1）加密算法过程：

```
Enc(X,Y)是加密函数
Dec(X,Y)是解密函数
Key是加密密钥；

Pi ( i = 0,1…n)是明文块，大小为64bit；
Ci ( i = 0,1…n)是密文块，大小为64bit;

XOR(X,Y)是异或运算；
IV是初始向量（一般为64位）；

ECB加密算法可表示为：
C0 = Enc(Key, XOR(IV, P0)，先将明文块进行异或操作，再加密
Ci = Enc(Key, XOR(Ci-1, Pi)，将上一个明文块加密得到密文块与当前明文块异或，再加密
...

ECB解密算法可以表示为：
P0 = XOR(IV, Dec(Key, C0))，先解密，再将其与初始向量异或还原
Pi = XOR(Ci-1, Dec(Key,Ci))，先解密，再将其与上一块的密文异或还原
```

2）算法特点：

（1）长度固定：每次加密的密文长度为64位(8个字节);

（2）一致性：当相同的明文使用相同的密钥和初始向量的时候CBC模式总是产生相同的密文;

（3）依赖性和有序性：密文块要依赖以前的操作结果,所以，密文块不能进行重新排列;

（4）初始向量：可以使用不同的初始化向量来避免相同的明文产生相同的密文,一定程度上抵抗字典攻击;

（5）关联影响：一个错误发生以后,当前和以后的密文都会被影响;

![](/images/java_basic/security/des-cbc-enc.jpg)

![](/images/java_basic/security/des-cbc-dec.jpg)

### 4. CFB（Cipher feedback，加密反馈模式）

加密反馈模式克服了需要等待8个字节才能加密的缺点，它采用了分组密码作为流密码的密钥流生成器；

1）加密过程：

需要使用一个与块的大小相同的移位寄存器，并用IV将寄存器初始化。然后，将寄存器内容使用块密码加密，然后将结果的最高x位与明文的x进行异或，以产生密文的x位。下一步将生成的x位密文移入寄存器中。继续对下面的x位明文重复这一过程。

解密过程与加密过程相似，以IV开始，对寄存器加密，将结果的高x与密文异或，产生x位明文，再将密文的下面x位移入寄存器。

2）流加密

流加密(stream cyphers)，一次加密明文中的一个位或一个字节。是指利用少量的密钥（制乱元素）通过某种复杂的运算（密码算法）产生大量的伪随机位流，用于对明文位流的加密。

每次加密一个块中的8bit，循环加密块中下一个的8bit，最终的加密块位于移位寄存器中。因此，移位寄存器的大小与加密块大小是相同的。

3）算法特点：

（1）每次加密的Pi和Ci不大于64位;

（2）加密算法和解密算法相同，不能适用于公钥算法；

（3）使用相同的密钥和初始向量的时候，相同明文使用CFB模式加密输出相同的密文;

（4）可以使用不同的初始化变量使相同的明文产生不同的密文，防止字典攻击;

（5）加密强度依赖于密钥长度;

（6）加密块长度过小时,会增加循环的数量,导致开销增加;

（7）加密块长度应是8位的整数倍(即字节为单位);

（8）一旦某位数据出错,会影响目前和其后8个块的数据;

![](/images/java_basic/security/des-cfb-process.jpg)

![](/images/java_basic/security/des-cfb.jpg)

### 5. OFB（Output Feedback，输出反馈模式）

与CFB模式不同之处在于, 加密位移寄存器与密文无关了,仅与加密key和加密算法有关；做法是不再把密文输入到加密移位寄存器，而是把输出的分组密文（Oi）输入到一位寄存器。

1）加密过程

输出反馈模式（Output feedback, OFB）可以将块密码变成同步的流密码。它产生密钥流的块，然后将其与明文块进行异或，得到密文。

每个使用OFB的输出块与其前面所有的输出块相关，因此不能并行化处理。然而，由于明文和密文只在最终的异或过程中使用，因此可以事先对IV进行加密，最后并行的将明文或密文进行并行的异或处理。

可以利用输入全0的CBC模式产生OFB模式的密钥流。这种方法十分实用，因为可以利用快速的CBC硬件实现来加速OFB模式的加密过程。

![](/images/java_basic/security/des-ofb.jpg)

2）允许错误校验：

与其它流密码一样，密文中一个位的翻转会使明文中同样位置的位也产生翻转。这种特性使得许多错误校正码，例如奇偶校验位，即使在加密前计算而在加密后进行校验也可以得出正确结果。

3）算法特点，与CFB类似,以下都是不同之处：

（1）因为密文没有参与链操作，所以使得OFB模式更容易受到攻击；

（2）不会进行错误传播，某位密文发生错误，只会影响该位对应的明文，而不会影响别的位；

（3）不是自同步的，如果加密和解密两个操作失去同步，那么系统需要重新初始化；

（4）每次重新同步时，应使用不同的初始向量。可以避免产生相同的比特流，避免"已知明文"攻击 